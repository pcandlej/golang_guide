# 如何获取指针的长度
Golang的编程体系里，指针是一种特殊变量，其核心作用是存储另一个变量的内存地址。系统会为每个变量分配特定的内存空间来存储数据，而内存地址通常以十六进制格式呈现，比如`0xFFAAF`这样的形式。对于刚接触Go语言的开发者来说，了解如何获取指针长度是基础且重要的知识点，本文将详细讲解这一操作的原理、方法及实际应用案例。

## 指针长度获取的核心：len()函数
在Go语言中，获取指针长度依赖于内置的`len()`函数，这是Go语言标准库`builtin`包中定义的核心函数之一，专门用于计算各类可迭代数据结构的元素数量，指针（特指指向数组的指针）也在此列。

### len()函数的关键特性
1. **函数语法**：`func len(l Type) int`，其中参数`l`的类型为指针，函数返回值为`int`类型，代表指针所指向数组中元素的总个数。
2. **nil指针兼容**：即便传入的指针为`nil`（空指针），`len()`函数依然能正常执行并返回正确的长度，不会因指针为空而抛出异常，这一特性极大提升了代码的稳定性。
3. **作用范围**：需要特别注意的是，`len()`函数仅对“指向数组的指针”有效。若指针指向切片、结构体等其他类型，直接使用`len()`函数会触发编译错误，这是因为不同数据类型的内存布局和迭代逻辑存在本质差异。

## 实际案例：获取指针长度的代码演示
为了更直观地理解如何使用`len()`函数获取指针长度，下面通过两个典型案例进行说明，涵盖基础用法与结合数组的实战场景。

### 案例1：基础指针长度获取
此案例展示了如何创建指向不同数据类型数组的指针，并直接通过`len()`函数获取其长度。

```go
package main

import "fmt"

func main() {
    // 1. 使用var关键字创建并初始化指向不同类型数组的指针
    // ptr1：指向存储6个int类型元素的数组的指针
    var ptr1 [6]*int
    // ptr2：指向存储3个string类型元素的数组的指针
    var ptr2 [3]*string
    // ptr3：指向存储4个float64类型元素的数组的指针
    var ptr3 [4]*float64

    // 2. 调用len()函数获取指针长度并打印结果
    fmt.Println("ptr1的长度：", len(ptr1))
    fmt.Println("ptr2的长度：", len(ptr2))
    fmt.Println("ptr3的长度：", len(ptr3))
}
```

**输出结果**：
```
ptr1的长度： 6
ptr2的长度： 3
ptr3的长度： 4
```

**代码解析**：在该案例中，`ptr1`、`ptr2`、`ptr3`分别是指向不同元素数量、不同数据类型数组的指针。`len()`函数根据指针指向数组的定义，准确返回了数组的元素个数，即指针的长度，结果与数组初始化时的元素数量完全一致。

### 案例2：结合数组操作的指针长度应用
此案例在创建数组的基础上，通过指针关联数组元素，再利用`len()`函数控制循环逻辑，同时获取数组和指针的长度，展示了指针长度在实际业务场景中的应用。

```go
package main

import "fmt"

func main() {
    // 1. 创建一个包含6个int类型元素的数组arr
    arr := [6]int{200, 300, 400, 500, 600, 700}
    // 定义循环变量x
    var x int

    // 2. 创建指向存储4个int类型元素的数组的指针p
    var p [4]*int

    // 3. 通过循环为指针p的每个元素分配数组arr对应索引的内存地址
    // 循环次数由指针p的长度决定（len(p) = 4）
    for x = 0; x < len(p); x++ {
        p[x] = &arr[x] // 将arr[x]的内存地址赋值给p[x]
    }

    // 4. 打印指针p中每个元素指向的数组元素的值
    fmt.Println("指针p指向的数组元素值：")
    for x = 0; x < len(p); x++ {
        // *p[x]：通过指针间接访问数组元素的值
        fmt.Printf("p[%d] = %d\n", x, *p[x])
    }

    // 5. 分别获取数组arr和指针p的长度并打印
    fmt.Println("数组arr的长度：", len(arr))
    fmt.Println("指针p的长度：", len(p))
}
```

**输出结果**：
```
指针p指向的数组元素值：
p[0] = 200
p[1] = 300
p[2] = 400
p[3] = 500
数组arr的长度： 6
指针p的长度： 4
```

**代码解析**：
1. 首先创建了数组`arr`，包含6个int类型元素；接着创建指针`p`，指向存储4个int类型元素的数组。
2. 第一个循环中，利用`len(p)`控制循环次数（共4次），将数组`arr`前4个元素的内存地址依次赋值给指针`p`的对应元素，建立指针与数组元素的关联。
3. 第二个循环通过指针间接访问数组元素的值并打印，验证了指针与数组元素的关联正确性。
4. 最后通过`len()`函数分别获取数组`arr`（长度6）和指针`p`（长度4）的长度，进一步说明`len()`函数对数组和指向数组的指针均有效，且返回结果与各自的元素数量匹配。

## 注意事项与常见误区
1. **指针类型限制**：`len()`函数仅支持“指向数组的指针”，若将其用于指向切片、结构体、int等非数组类型的指针，会触发编译错误。例如：`var ptr *int; fmt.Println(len(ptr))` 这一代码会报错，因为`ptr`是指向int类型的指针，而非指向数组的指针。
2. **长度本质**：指针的长度本质上是其指向数组的元素个数，而非指针变量本身占用的内存空间大小。若需获取指针变量自身的内存大小，应使用`unsafe.Sizeof()`函数（需导入`unsafe`包），例如：`var ptr [6]*int; fmt.Println(unsafe.Sizeof(ptr))`，该代码会返回指针变量`ptr`在内存中占用的字节数。
3. **nil指针处理**：如前文所述，即便指针为`nil`，`len()`函数仍能正常返回长度。例如：`var ptr [5]*string = nil; fmt.Println(len(ptr))`，输出结果为5，这一特性在处理可能为空的指针时非常实用，可避免额外的空指针判断逻辑。

通过本文的讲解，相信开发者已掌握在Go语言中获取指针长度的核心方法。在实际开发中，需明确指针的指向类型，合理运用`len()`函数，同时规避常见误区，确保代码的正确性与高效性。