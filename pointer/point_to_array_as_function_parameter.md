# Go语言中数组指针作为函数参数的用法

## 一、核心概念与基础原理
1. **关键前置知识**
    - **指针**：Go语言中存储另一个变量内存地址的特殊变量，可实现对目标变量的间接操作。
    - **数组**：固定长度、存储同类型元素的序列，长度是数组类型的重要组成部分（如`[5]int`与`[6]int`是不同类型）。
2. **核心逻辑**：当需要在函数内部修改数组内容并让修改在调用处生效时，可将“数组指针”作为函数参数。通过传递数组的内存地址，函数能直接操作原始数组的内存空间，避免数组按值传递时产生副本（尤其对大型数组可减少内存开销）。

## 二、实现示例与语法细节
### 1. 数组指针作为函数参数的示例
```go
package main
import "fmt"

// 函数参数为指向长度为5的int数组的指针
func updatearray(funarr *[5]int) {
    // 方式1：通过解引用指针修改数组元素（标准语法）
    (*funarr)[4] = 750
    // 方式2：Go语言语法糖，可省略解引用直接访问（效果与方式1一致）
    // funarr[4] = 750
}

func main() {
    // 定义长度为5的int数组
    arr := [5]int{78, 89, 45, 56, 14}
    // 传递数组的内存地址（即数组指针）给函数
    updatearray(&arr)
    // 输出修改后的数组，结果为[78 89 45 56 750]
    fmt.Println(arr)
}
```
- **关键操作**：通过`&arr`获取数组的内存地址（数组指针），作为参数传入函数；函数内部通过`(*funarr)[索引]`或简化的`funarr[索引]`修改原始数组元素。
- **输出结果**：函数内的修改会直接作用于原始数组，最终打印`[78 89 45 56 750]`。

### 2. 语法简化特性
Go语言对数组指针的访问提供语法糖：无需显式解引用（`*`），可直接通过`数组指针变量[索引]`访问数组元素，如示例中`funarr[4] = 750`与`(*funarr)[4] = 750`功能完全相同，仅为简化代码书写。

## 三、局限性与推荐替代方案
### 1. 数组指针作为函数参数的不足
在Go语言中**不推荐**使用“数组指针作为函数参数”，主要原因是：
- **可读性差**：代码中需处理指针和解引用逻辑，相比直接操作数据结构，理解成本更高。
- **灵活性低**：数组长度是其类型的一部分，若函数参数定义为`*[5]int`，则仅能接收长度为5的int数组指针，无法复用给其他长度的数组，扩展性差。

### 2. 更优方案：使用切片（Slice）
Go语言中，**切片（Slice）是替代“数组指针传参”的推荐方式**，切片本身包含指向底层数组的指针、长度和容量，传递切片时本质是传递切片结构体的副本（占用内存小），且能灵活适配不同长度的底层数组，同时可直接修改底层数组内容。

#### 切片实现相同功能的示例
```go
package main
import "fmt"

// 函数参数为int类型切片（无需指定固定长度）
func updateslice(funarr []int) {
    // 直接修改切片元素（本质是修改底层数组）
    funarr[4] = 750
}

func main() {
    // 定义长度为5的int数组
    sArr := [5]int{78, 89, 45, 56, 14}
    // 将数组转换为切片（sArr[:]表示取数组全部元素构成切片）
    updateslice(sArr[:])
    // 输出修改后的数组，结果同样为[78 89 45 56 750]
    fmt.Println(sArr)
}
```
- **优势**：代码更简洁（无需处理指针）、灵活性更高（函数可接收任意长度的int切片）、可读性更强，完全满足“修改原始数据并在调用处生效”的需求，是Go语言中的惯用写法。
- **输出结果**：与数组指针传参示例一致，最终打印`[78 89 45 56 750]`。