# Go语言数组
在Go语言中，数组是一种基础且重要的数据结构，用于存储固定长度的同类型元素集合。无论是存储学生成绩、用户ID列表，还是多维数据矩阵，数组都能提供高效的存储和访问能力。与Go语言中的切片（Slice）不同，数组的长度固定不变，这一特性使其在内存占用和访问性能上具有独特优势。本文将详细介绍Go语言数组的定义、创建方式、核心特性及实战应用，帮助开发者全面掌握数组的使用技巧。

## 一、数组的核心概念
数组是**固定长度**的**同类型元素序列**，在内存中连续存储。其核心特点包括：
- **同质性**：数组中所有元素必须是相同数据类型，例如全部为int、string或自定义类型。
- **固定长度**：创建数组时必须指定长度（或通过初始化元素自动推导），长度一旦确定无法修改。
- **零值初始化**：未显式初始化的数组元素会被自动赋予对应类型的零值（int为0，string为空字符串，bool为false等）。
- **零基索引**：元素访问通过索引进行，首个元素索引为0，最后一个元素索引为`len(array)-1`。

例如存储6名学生的成绩，数组结构如下：
| 索引 | 0 | 1 | 2 | 3 | 4 | 5 |
|------|---|---|---|---|---|---|
| 元素 | 20 | 50 | 60 | 70 | 80 | 90 |

## 二、数组的创建与初始化
Go语言提供两种主要的数组创建方式，分别适用于不同场景：

### 1. 使用var关键字声明
通过`var`关键字指定数组名称、长度和元素类型，可选择显式初始化或依赖零值初始化。
- 语法：`var 数组名[长度]类型 [元素列表]`
- 示例：
```go
package main

import "fmt"

func main() {
    // 声明并初始化int类型数组
    var scores[6]int = [6]int{20, 50, 60, 70, 80, 90}
    fmt.Println("学生成绩数组：", scores)

    // 声明未初始化，元素默认为零值
    var emptyArr[3]string
    fmt.Println("零值数组：", emptyArr) // 输出：[  ]

    // 指定索引初始化（跳过的元素仍为零值）
    var partialArr[5]int
    partialArr[0] = 10
    partialArr[3] = 40
    fmt.Println("部分初始化数组：", partialArr) // 输出：[10 0 0 40 0]
}
```

### 2. 短变量声明（ shorthand declaration）
使用`:=`语法，可省略var关键字和类型声明（由元素类型自动推导），更简洁灵活，是日常开发的首选方式。
- 语法：`数组名 := [长度]类型{元素1, 元素2, ..., 元素N}`
- 示例：
```go
package main

import "fmt"

func main() {
    // 完整初始化，长度与元素个数一致
    fruits := [3]string{"苹果", "香蕉", "橙子"}
    fmt.Println("水果数组：", fruits)

    // 省略类型声明（自动推导为string类型）
    colors := [4]{"红", "绿", "蓝", "黄"}
    fmt.Println("颜色数组：", colors)

    // 椭圆运算符自动推导长度（最常用）
    numbers := [...]int{1, 3, 5, 7, 9}
    fmt.Println("奇数数组：", numbers)
    fmt.Println("数组长度：", len(numbers)) // 输出：5
}
```

**关键说明**：椭圆运算符`...`的作用是让Go语言根据初始化元素的个数自动计算数组长度，避免手动计算长度导致的错误，尤其适用于元素较多的场景。

## 三、多维数组
Go语言仅支持一维数组，但可通过"数组的数组"实现多维数组（常见为二维数组），适用于存储矩阵、表格等结构化数据。

### 1. 二维数组的创建
- 语法：`数组名 := [行数][列数]类型{{行1元素}, {行2元素}, ...}`
- 示例：
```go
package main

import "fmt"

func main() {
    // 短变量声明创建二维字符串数组（3行3列）
    languages := [3][3]string{
        {"C#", "C", "Python"},
        {"Java", "Scala", "Perl"},
        {"C++", "Go", "HTML"},
    }

    // var关键字创建二维int数组并手动赋值
    var matrix[2][2]int
    matrix[0][0] = 10
    matrix[0][1] = 20
    matrix[1][0] = 30
    matrix[1][1] = 40

    // 访问二维数组元素
    fmt.Println("第一行第二列语言：", languages[0][1]) // 输出：C
    fmt.Println("矩阵元素(1,0)：", matrix[1][0])     // 输出：30
}
```

### 2. 多维数组的特性
- 未显式初始化的元素会被赋予零值（如int二维数组未赋值元素为0）。
- 访问元素需通过多层索引（如`array[x][y]`表示第x行第y列元素）。
- 支持嵌套for循环遍历所有元素。

## 四、数组的访问与遍历
数组元素的访问和遍历是数组操作的核心，Go语言提供多种灵活方式：

### 1. 直接通过索引访问
通过`数组名[索引]`直接读写元素，索引范围必须在`0 ~ len(array)-1`之间，否则会触发运行时错误。
```go
package main

import "fmt"

func main() {
    arr := [5]int{10, 20, 30, 40, 50}
    fmt.Println("第三个元素：", arr[2]) // 输出：30

    // 修改元素值
    arr[3] = 400
    fmt.Println("修改后数组：", arr) // 输出：[10 20 30 400 50]
}
```

### 2. for循环遍历
通过普通for循环遍历索引，适用于需要索引参与逻辑的场景：
```go
package main

import "fmt"

func main() {
    arr := [...]string{"a", "b", "c", "d"}
    fmt.Println("数组元素：")
    for i := 0; i < len(arr); i++ {
        fmt.Printf("索引%d：%s\n", i, arr[i])
    }
}
```

### 3. for-range遍历
使用`for-range`语法可同时获取索引和元素，代码更简洁，是遍历数组的推荐方式：
```go
package main

import "fmt"

func main() {
    numbers := [...]int{29, 79, 49, 39, 20}
    fmt.Println("数组元素：")
    for idx, val := range numbers {
        fmt.Printf("索引%d：%d\n", idx, val)
    }
}
```

## 五、数组的核心特性与注意事项
### 1. 数组是值类型
Go语言中数组属于**值类型**，而非引用类型。这意味着：
- 数组赋值给新变量时，会复制整个数组的所有元素（而非引用地址）。
- 新变量的修改不会影响原数组，反之亦然。
- 函数参数传递数组时，同样会复制整个数组，效率较低（大数据量建议使用切片或指针）。

示例：
```go
package main

import "fmt"

func main() {
    original := [...]int{100, 200, 300}
    copyArr := original // 复制整个数组

    copyArr[0] = 500 // 修改复制数组
    fmt.Println("原数组：", original)  // 输出：[100 200 300]（无变化）
    fmt.Println("复制数组：", copyArr) // 输出：[500 200 300]
}
```

### 2. 数组的可比性
如果数组的元素类型是可比较的（如int、string、bool等），则该数组类型也是可比较的，可直接使用`==`或`!=`运算符比较两个数组。比较规则：
- 数组长度必须相同（否则编译报错）。
- 所有对应索引的元素必须相等。

示例：
```go
package main

import "fmt"

func main() {
    arr1 := [3]int{1, 2, 3}
    arr2 := [...]int{1, 2, 3} // 长度自动推导为3
    arr3 := [3]int{1, 2, 4}

    fmt.Println(arr1 == arr2) // 输出：true（长度和元素均相同）
    fmt.Println(arr1 == arr3) // 输出：false（元素不同）

    // arr4 := [4]int{1,2,3}
    // fmt.Println(arr1 == arr4) // 编译报错：数组长度不匹配
}
```

### 3. 数组与切片的区别
数组和切片（Slice）是Go语言中容易混淆的两个概念，核心区别如下：

| 特性         | 数组                     | 切片                     |
|--------------|--------------------------|--------------------------|
| 长度         | 固定不变                 | 动态可变                 |
| 类型标识     | 包含长度（如[5]int）     | 不包含长度（如[]int）    |
| 赋值/传参    | 复制整个数据             | 传递引用（底层数组指针） |
| 灵活性       | 较低                     | 较高（支持扩容、裁剪）   |
| 零值         | 元素均为零值的数组       | nil（无底层数组）        |

## 六、数组的实战应用场景
### 1. 存储固定长度的同类型数据
例如存储固定数量的配置项、用户ID列表、传感器采集的固定次数数据等：
```go
// 存储3个服务器的IP地址
servers := [3]string{
    "192.168.1.100",
    "192.168.1.101",
    "192.168.1.102",
}
```

### 2. 多维数组存储矩阵数据
适用于数学计算、图表绘制等场景，例如存储3x3的矩阵并计算对角线元素和：
```go
package main

import "fmt"

func main() {
    matrix := [3][3]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }

    sum := 0
    for i := 0; i < 3; i++ {
        sum += matrix[i][i] // 累加对角线元素（0,0）、（1,1）、（2,2）
    }
    fmt.Println("对角线元素和：", sum) // 输出：15
}
```

### 3. 作为函数参数传递固定长度数据
当需要限制输入数据的长度时，数组是比切片更安全的选择：
```go
package main

import "fmt"

// 仅接受长度为5的int数组
func printArray(arr [5]int) {
    for _, val := range arr {
        fmt.Printf("%d ", val)
    }
    fmt.Println()
}

func main() {
    arr1 := [5]int{1,2,3,4,5}
    printArray(arr1) // 输出：1 2 3 4 5

    // arr2 := [4]int{1,2,3,4}
    // printArray(arr2) // 编译报错：数组长度不匹配
}
```

## 七、总结
Go语言的数组是一种高效、安全的固定长度数据结构，适用于存储同类型的固定数量元素。其核心优势在于内存连续分配带来的快速访问性能，以及编译时长度检查带来的类型安全性。通过本文的介绍，我们掌握了数组的创建、初始化、访问、遍历等基础操作，理解了其值类型、可比性等核心特性，并明确了与切片的区别。

在实际开发中，若数据长度固定且无需动态调整，优先使用数组；若需要灵活增减元素，则应选择切片。合理运用数组，能让代码在性能和安全性上得到更好的平衡。
