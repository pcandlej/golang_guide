# Go语言数组传参-值传递与指针传递的实战解析
在Go语言中，数组作为固定长度的同类型数据集合，常需在函数间传递以实现数据复用或加工。由于数组是**值类型**的特性，其传参方式直接影响代码的性能和逻辑正确性。Go语言支持两种核心的数组传参方式：值传递和指针传递，分别适配“只读不修改”和“需修改原数组”的场景。本文将深入拆解两种传参方式的原理、实现、优缺点及适用场景，结合实战示例帮助开发者精准掌握数组传参技巧。

## 一、数组传参的核心前提
在传递数组前，需明确一个关键特性：**数组的长度是其类型的一部分**。例如`[5]int`和`[10]int`是完全不同的类型，若函数参数声明的数组长度与实际传递的数组长度不匹配，会直接触发编译错误。

示例：错误的数组传参（长度不匹配）
```go
package main

import "fmt"

// 函数参数为长度5的int数组
func printArray(arr [5]int) {
    fmt.Println(arr)
}

func main() {
    arr1 := [5]int{1,2,3,4,5}
    arr2 := [6]int{1,2,3,4,5,6} // 长度为6，与函数参数类型不匹配
    
    printArray(arr1) // 正确：类型匹配
    // printArray(arr2) // 编译报错：cannot use arr2 (type [6]int) as type [5]int in argument to printArray
}
```

这一特性决定了数组传参的“强类型约束”——函数只能接收固定长度的数组，灵活性低于切片，但胜在类型安全和内存布局可预测。

## 二、方式一：值传递（默认传参方式）
Go语言中数组默认以“值传递”方式传入函数，即函数接收的是原数组的**完整拷贝**，而非原数组本身。函数内部对数组的修改仅作用于拷贝后的临时数组，不会影响原数组。

### 1. 原理与实现
值传递的本质是：函数调用时，Go会为参数分配新的内存空间，将原数组的所有元素逐一复制到新内存中。函数内部操作的是这份拷贝，原数组的内存空间与拷贝完全独立，修改互不干扰。

#### 语法与示例（计算数组平均值）
```go
package main

import "fmt"

// 函数参数：长度6的int数组 + 数组长度（冗余但可增强可读性）
func calculateAverage(arr [6]int) int {
    sum := 0
    // 遍历拷贝后的数组计算总和
    for _, val := range arr {
        sum += val
    }
    // 返回平均值（整数除法）
    return sum / len(arr)
}

func main() {
    // 原数组：6名学生成绩
    scores := [6]int{67, 59, 29, 35, 4, 34}
    
    // 传参：原数组的拷贝被传入函数
    average := calculateAverage(scores)
    
    fmt.Printf("成绩数组：%v\n", scores)  // 输出：成绩数组：[67 59 29 35 4 34]（原数组无变化）
    fmt.Printf("平均成绩：%d\n", average) // 输出：平均成绩：38
}
```

#### 关键特性验证（修改拷贝不影响原数组）
```go
package main

import "fmt"

// 函数内部修改拷贝后的数组
func modifyArray(arr [5]int) {
    arr[0] = 100 // 仅修改临时拷贝
    fmt.Println("函数内数组：", arr) // 输出：函数内数组： [100 2 3 4 5]
}

func main() {
    original := [5]int{1,2,3,4,5}
    modifyArray(original)
    fmt.Println("函数外原数组：", original) // 输出：函数外原数组： [1 2 3 4 5]（无变化）
}
```

### 2. 优缺点与适用场景
- **优点**：
  - 类型安全：函数操作的是拷贝，不会意外修改原数组，避免副作用；
  - 逻辑简单：无需关注指针操作，降低代码复杂度。
- **缺点**：
  - 性能开销：数组元素越多，拷贝消耗的内存和CPU资源越大（大型数组不适用）；
  - 内存冗余：拷贝数组与原数组占用两份独立内存，浪费空间。

- **适用场景**：
  - 数组长度较小（如100元素以内），拷贝开销可忽略；
  - 函数仅需读取数组数据，无需修改原数组；
  - 要求函数操作不影响外部状态（纯函数场景）。

## 三、方式二：指针传递（修改原数组的方案）
若需在函数内部修改原数组（如更新元素值、批量处理数据），需通过“指针传递”方式：将原数组的**内存地址**（指针）传入函数，函数通过指针间接操作原数组的内存，修改会直接同步到原数组。

### 1. 原理与实现
指针传递的本质是：函数接收的是`*[n]T`类型的指针（指向原数组的内存地址），而非数组本身。函数内部通过`*arr`（解引用）访问原数组元素，所有修改操作直接作用于原数组的内存空间，无需拷贝数据。

#### 语法与示例（批量修改数组元素）
```go
package main

import "fmt"

// 函数参数：指向长度5的int数组的指针
func incrementArray(arr *[5]int) {
    // 解引用指针，遍历并修改原数组元素
    for i := range arr {
        arr[i]++ // 等价于 (*arr)[i]++，Go语法糖允许省略*
    }
}

func main() {
    values := [5]int{1, 2, 3, 4, 5}
    fmt.Println("修改前原数组：", values) // 输出：修改前原数组： [1 2 3 4 5]
    
    // 传参：传递原数组的内存地址（&values）
    incrementArray(&values)
    
    fmt.Println("修改后原数组：", values) // 输出：修改后原数组： [2 3 4 5 6]（原数组被修改）
}
```

#### 关键特性验证（共享内存，修改同步）
```go
package main

import "fmt"

func updateElement(arr *[3]string, index int, newValue string) {
    arr[index] = newValue // 通过指针修改原数组指定索引元素
}

func main() {
    fruits := [3]string{"苹果", "香蕉", "橙子"}
    updateElement(&fruits, 1, "葡萄") // 传递指针，修改索引1的元素
    fmt.Println("修改后数组：", fruits) // 输出：修改后数组： [苹果 葡萄 橙子]
}
```

### 2. 优缺点与适用场景
- **优点**：
  - 性能最优：无需拷贝数组，仅传递8字节指针（64位系统），适合大型数组；
  - 支持修改原数组：满足批量更新、数据加工等场景需求。
- **缺点**：
  - 可能产生副作用：函数修改会直接影响原数组，若逻辑不当易引发bug；
  - 需关注指针安全：避免传递空指针（需提前校验）。

- **适用场景**：
  - 数组长度较大（如1000元素以上），需降低拷贝开销；
  - 函数需修改原数组（如数据过滤、批量更新）；
  - 内存资源紧张，需避免冗余拷贝。

## 四、两种传参方式核心对比
为方便开发者快速选择，以下是值传递与指针传递的关键特性对比：

| 对比维度         | 值传递                          | 指针传递                          |
|------------------|---------------------------------|-----------------------------------|
| 本质             | 传递原数组的完整拷贝            | 传递原数组的内存地址（指针）      |
| 内存开销         | 高（两份独立数组内存）          | 低（仅存储指针）                  |
| 原数组影响       | 无（修改仅作用于拷贝）          | 有（修改直接同步原数组）          |
| 语法复杂度       | 低（直接传递数组）              | 中（需使用&取地址、*解引用）      |
| 类型约束         | 函数参数长度需与数组完全匹配    | 函数参数指针类型需与数组完全匹配  |
| 适用数组规模     | 小型、中型数组（拷贝开销小）    | 大型数组（避免拷贝开销）          |
| 典型场景         | 只读操作（计算、查询、打印）    | 写操作（修改、更新、批量处理）    |

## 五、常见问题与避坑指南
### 1. 混淆数组与切片的传参逻辑
数组是值类型，默认值传递；切片是引用类型，默认传递引用（类似指针传递），这是最易混淆的点：
```go
// 数组值传递：修改不影响原数组
func modifyArr(arr [3]int) { arr[0] = 100 }

// 切片引用传递：修改影响原切片（共享底层数组）
func modifySlice(slc []int) { slc[0] = 100 }

func main() {
    arr := [3]int{1,2,3}
    slc := []int{1,2,3}
    
    modifyArr(arr)  // 原数组不变：[1,2,3]
    modifySlice(slc)// 原切片变化：[100,2,3]
}
```

### 2. 函数参数长度与数组不匹配
数组长度是类型的一部分，即使元素类型相同，长度不匹配也会编译报错：
```go
func process(arr [5]int) {}

func main() {
    arr1 := [5]int{1,2,3,4,5}
    arr2 := [5]int{6,7,8,9,10}
    arr3 := [6]int{1,2,3,4,5,6}
    
    process(arr1) // 正确
    process(arr2) // 正确（长度匹配）
    // process(arr3) // 错误：类型不匹配（[6]int vs [5]int）
}
```

### 3. 指针传递时的空指针风险
若传递空指针（`nil`）给函数，解引用时会触发运行时恐慌（panic），需提前校验：
```go
func safeModify(arr *[5]int) {
    if arr == nil { // 校验空指针
        fmt.Println("错误：传入空指针")
        return
    }
    arr[0] = 100
}

func main() {
    var nilArr *[5]int // 空指针（未指向任何数组）
    safeModify(nilArr) // 输出：错误：传入空指针（无恐慌）
}
```

### 4. 误将数组当切片传参
数组不能直接传递给切片类型的参数，需通过切片表达式`arr[:]`转换为切片：
```go
func processSlice(slc []int) {}

func main() {
    arr := [5]int{1,2,3,4,5}
    // processSlice(arr) // 错误：[5]int 不能直接转换为 []int
    processSlice(arr[:]) // 正确：将数组转换为切片传递
}
```

## 六、总结
Go语言数组的传参方式本质是由其“值类型”特性决定的，核心选择逻辑如下：
1. 若函数仅需读取数组数据，且数组规模较小，优先使用**值传递**，兼顾类型安全和逻辑简洁；
2. 若函数需修改原数组，或数组规模较大（拷贝开销高），优先使用**指针传递**，提升性能并实现数据同步；
3. 若需灵活适配不同长度的数组，建议将数组转换为切片（`arr[:]`）后传递，利用切片的动态特性降低类型约束。

掌握两种传参方式的核心差异，结合场景选择合适的方案，既能避免不必要的性能开销，又能减少副作用带来的逻辑bug，让数组操作更高效、稳健。
